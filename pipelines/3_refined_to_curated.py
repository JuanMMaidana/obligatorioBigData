#!/usr/bin/env python3
"""
Pipeline 3: Transformaci√≥n Refined a Curated
============================================

Este script implementa la tercera etapa del pipeline ETL, donde se procesan los datos
de la zona REFINED hacia la zona CURATED del Data Lake.

Zona CURATED:
- Productos de datos agregados y listos para el negocio
- KPIs que responden directamente a preguntas de negocio
- Datos optimizados para dashboards y reportes
- M√©tricas calculadas con relevancia estad√≠stica
- Informaci√≥n estrat√©gica para la toma de decisiones
"""

from pyspark.sql import SparkSession
from pyspark.sql.functions import *
from pyspark.sql.types import *
import os

def create_spark_session():
    """
    Crea una sesi√≥n de Spark configurada para el procesamiento de datos.
    
    Returns:
        SparkSession: Sesi√≥n de Spark configurada
    """
    return SparkSession.builder \
        .appName("MovieDataLake-CuratedAggregation") \
        .config("spark.sql.adaptive.enabled", "true") \
        .config("spark.sql.adaptive.coalescePartitions.enabled", "true") \
        .getOrCreate()

def load_master_data(spark):
    """
    Carga el dataset maestro desde la zona REFINED.
    
    Args:
        spark (SparkSession): Sesi√≥n de Spark
        
    Returns:
        DataFrame: Dataset maestro de pel√≠culas
    """
    print("üìñ Cargando dataset maestro desde zona REFINED...")
    
    master_df = spark.read.parquet("datalake/refined/movies_master.parquet")
    
    print(f"üìä Registros cargados: {master_df.count()}")
    
    return master_df

def create_director_performance_kpis(master_df):
    """
    Crea el producto de datos de rendimiento de directores.
    
    Este KPI responde preguntas clave del negocio como:
    - ¬øQu√© directores tienen el mejor ROI consistente?
    - ¬øCu√°les son los directores m√°s prol√≠ficos?
    - ¬øEn qu√© directores deber√≠amos invertir?
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: KPIs de rendimiento de directores
    """
    print("üé¨ Creando KPIs de rendimiento de directores...")
    
    # Agrupar por director y calcular m√©tricas de rendimiento
    director_performance = master_df.groupBy("director") \
        .agg(
            count("id").alias("numero_peliculas"),
            avg("roi").alias("roi_promedio"),
            expr("percentile_approx(roi, 0.5)").alias("roi_mediano"),
            stddev("roi").alias("roi_stddev"),
            sum("profit").alias("ganancia_total"),
            avg("budget").alias("presupuesto_promedio"),
            avg("revenue").alias("recaudacion_promedio")
        )
    
    # Filtrar directores con relevancia estad√≠stica (3 o m√°s pel√≠culas)
    director_performance_filtered = director_performance.filter(
        col("numero_peliculas") >= 3
    )
    
    # Redondear valores decimales para mejor presentaci√≥n
    director_performance_final = director_performance_filtered.withColumn(
        "roi_promedio", round(col("roi_promedio"), 3)
    ).withColumn(
        "roi_mediano", round(col("roi_mediano"), 3)
    ).withColumn(
        "roi_stddev", round(col("roi_stddev"), 3)
    ).withColumn(
        "ganancia_total", round(col("ganancia_total"), 2)
    ).withColumn(
        "presupuesto_promedio", round(col("presupuesto_promedio"), 2)
    ).withColumn(
        "recaudacion_promedio", round(col("recaudacion_promedio"), 2)
    )
    
    # Ordenar por ROI mediano descendente (priorizar mediana sobre promedio)
    director_performance_final = director_performance_final.orderBy(
        desc("roi_mediano")
    )
    
    print(f"üìä Directores con relevancia estad√≠stica: {director_performance_final.count()}")
    
    return director_performance_final

def create_genre_performance_kpis(master_df):
    """
    Crea el producto de datos de rendimiento de g√©neros.
    
    Este KPI responde preguntas clave del negocio como:
    - ¬øQu√© g√©neros tienen el mejor ROI consistente?
    - ¬øCu√°les son los g√©neros m√°s prol√≠ficos?
    - ¬øEn qu√© g√©neros deber√≠amos invertir?
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: KPIs de rendimiento de g√©neros
    """
    print("üé≠ Creando KPIs de rendimiento de g√©neros...")
    
    # Crear un DataFrame expandido con m√∫ltiples filas por pel√≠cula (una por g√©nero)
    # Usar split para dividir por las comas y luego extraer cada g√©nero
    genre_df = master_df.select("*") \
        .withColumn("genre_1", regexp_extract(col("genres"), r"'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_2", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_3", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1))
    
    # Crear DataFrame con una fila por g√©nero
    genre_1_df = genre_df.select("*", col("genre_1").alias("genre")).filter(col("genre_1") != "")
    genre_2_df = genre_df.select("*", col("genre_2").alias("genre")).filter(col("genre_2") != "")
    genre_3_df = genre_df.select("*", col("genre_3").alias("genre")).filter(col("genre_3") != "")
    
    # Unir todos los g√©neros
    all_genres_df = genre_1_df.union(genre_2_df).union(genre_3_df)
    
    # Agrupar por g√©nero y calcular m√©tricas de rendimiento
    genre_performance = all_genres_df.groupBy("genre") \
        .agg(
            count("id").alias("numero_peliculas"),
            avg("roi").alias("roi_promedio"),
            expr("percentile_approx(roi, 0.5)").alias("roi_mediano"),
            stddev("roi").alias("roi_stddev"),
            sum("profit").alias("ganancia_total"),
            avg("budget").alias("presupuesto_promedio"),
            avg("revenue").alias("recaudacion_promedio")
        )
    
    # Filtrar g√©neros con relevancia estad√≠stica (10 o m√°s pel√≠culas)
    genre_performance_filtered = genre_performance.filter(
        col("numero_peliculas") >= 10
    )
    
    # Redondear valores decimales para mejor presentaci√≥n
    genre_performance_final = genre_performance_filtered.withColumn(
        "roi_promedio", round(col("roi_promedio"), 3)
    ).withColumn(
        "roi_mediano", round(col("roi_mediano"), 3)
    ).withColumn(
        "roi_stddev", round(col("roi_stddev"), 3)
    ).withColumn(
        "ganancia_total", round(col("ganancia_total"), 2)
    ).withColumn(
        "presupuesto_promedio", round(col("presupuesto_promedio"), 2)
    ).withColumn(
        "recaudacion_promedio", round(col("recaudacion_promedio"), 2)
    )
    
    # Ordenar por ROI mediano descendente
    genre_performance_final = genre_performance_final.orderBy(
        desc("roi_mediano")
    )
    
    print(f"üìä G√©neros con relevancia estad√≠stica: {genre_performance_final.count()}")
    
    return genre_performance_final

def create_genre_roi_distribution(master_df):
    """
    Crea el producto de datos desagregado para Box Plot de g√©neros.
    
    Este dataset contiene los datos sin agregar para crear visualizaciones
    de distribuci√≥n detalladas como Box Plots.
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: Datos desagregados de g√©nero y ROI
    """
    print("üì¶ Creando distribuci√≥n desagregada de g√©neros y ROI...")
    
    # Extraer g√©neros del string JSON usando expresi√≥n regular
    genre_df = master_df.select("id", "roi", "genres") \
        .withColumn("genre_1", regexp_extract(col("genres"), r"'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_2", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_3", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1))
    
    # Crear distribuci√≥n desagregada
    genre_1_dist = genre_df.select("id", "roi", col("genre_1").alias("genre")).filter(col("genre_1") != "")
    genre_2_dist = genre_df.select("id", "roi", col("genre_2").alias("genre")).filter(col("genre_2") != "")
    genre_3_dist = genre_df.select("id", "roi", col("genre_3").alias("genre")).filter(col("genre_3") != "")
    
    # Unir todas las distribuciones
    genre_distribution = genre_1_dist.union(genre_2_dist).union(genre_3_dist) \
        .filter(col("roi").isNotNull() & (col("genre") != ""))
    
    print(f"üìä Registros de distribuci√≥n: {genre_distribution.count()}")
    
    return genre_distribution

def create_yearly_trends_kpis(master_df):
    """
    Crea el producto de datos de tendencias anuales del mercado.
    
    Este KPI responde preguntas clave del negocio como:
    - ¬øC√≥mo ha evolucionado el mercado cinematogr√°fico?
    - ¬øEn qu√© a√±os fue m√°s rentable la industria?
    - ¬øCu√°les son las tendencias de presupuesto y recaudaci√≥n?
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: KPIs de tendencias anuales
    """
    print("üìà Creando KPIs de tendencias anuales del mercado...")
    
    # Agrupar por a√±o y calcular m√©tricas de mercado
    yearly_trends = master_df.groupBy("release_year") \
        .agg(
            count("id").alias("numero_peliculas"),
            avg("budget").alias("presupuesto_promedio"),
            sum("revenue").alias("recaudacion_total"),
            avg("roi").alias("roi_promedio_anual"),
            expr("percentile_approx(roi, 0.5)").alias("roi_mediano_anual"),
            stddev("roi").alias("roi_stddev_anual"),
            sum("profit").alias("ganancia_total_anual"),
            avg("profit").alias("ganancia_promedio")
        )
    
    # Redondear valores decimales para mejor presentaci√≥n
    yearly_trends_final = yearly_trends.withColumn(
        "presupuesto_promedio", round(col("presupuesto_promedio"), 2)
    ).withColumn(
        "recaudacion_total", round(col("recaudacion_total"), 2)
    ).withColumn(
        "roi_promedio_anual", round(col("roi_promedio_anual"), 3)
    ).withColumn(
        "roi_mediano_anual", round(col("roi_mediano_anual"), 3)
    ).withColumn(
        "roi_stddev_anual", round(col("roi_stddev_anual"), 3)
    ).withColumn(
        "ganancia_total_anual", round(col("ganancia_total_anual"), 2)
    ).withColumn(
        "ganancia_promedio", round(col("ganancia_promedio"), 2)
    )
    
    # Ordenar por a√±o
    yearly_trends_final = yearly_trends_final.orderBy("release_year")
    
    print(f"üìä A√±os con datos: {yearly_trends_final.count()}")
    
    return yearly_trends_final

def create_genre_success_rate(master_df):
    """
    Crea el producto de datos de tasa de √©xito por g√©nero.
    
    Esta m√©trica mide el riesgo de cada g√©nero calculando el porcentaje
    de pel√≠culas que son rentables (ROI > 0).
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: Tasa de √©xito por g√©nero
    """
    print("üìä Creando tasa de √©xito por g√©nero...")
    
    # Extraer g√©neros del string JSON usando expresi√≥n regular
    genre_df = master_df.select("*") \
        .withColumn("genre_1", regexp_extract(col("genres"), r"'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_2", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1)) \
        .withColumn("genre_3", regexp_extract(col("genres"), r"'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'[^']+',\s*[^}]+},\s*\{[^}]*'name':\s*'([^']+)'", 1))
    
    # Crear columna de rentabilidad
    genre_with_profit = genre_df.withColumn("is_profitable", when(col("roi") > 0, 1).otherwise(0))
    
    # Crear DataFrame con una fila por g√©nero
    genre_1_df = genre_with_profit.select("*", col("genre_1").alias("genre")).filter(col("genre_1") != "")
    genre_2_df = genre_with_profit.select("*", col("genre_2").alias("genre")).filter(col("genre_2") != "")
    genre_3_df = genre_with_profit.select("*", col("genre_3").alias("genre")).filter(col("genre_3") != "")
    
    # Unir todos los g√©neros
    all_genres_df = genre_1_df.union(genre_2_df).union(genre_3_df)
    
    # Calcular tasa de √©xito por g√©nero
    success_rate_df = all_genres_df.groupBy("genre") \
        .agg(
            count("id").alias("total_movies"),
            sum("is_profitable").alias("profitable_movies")
        ) \
        .withColumn("success_rate", col("profitable_movies") / col("total_movies")) \
        .withColumn("success_rate", round(col("success_rate"), 3)) \
        .orderBy(desc("success_rate"))
    
    # Filtrar g√©neros con relevancia estad√≠stica (10 o m√°s pel√≠culas)
    success_rate_filtered = success_rate_df.filter(col("total_movies") >= 10)
    
    print(f"üìä G√©neros con tasa de √©xito calculada: {success_rate_filtered.count()}")
    
    return success_rate_filtered

def create_budget_range_analysis(master_df):
    """
    Crea el producto de datos de an√°lisis por rango de presupuesto.
    
    Esta m√©trica analiza el rendimiento por categor√≠as de presupuesto
    para estrategias de inversi√≥n.
    
    Args:
        master_df (DataFrame): Dataset maestro de pel√≠culas
        
    Returns:
        DataFrame: An√°lisis por rango de presupuesto
    """
    print("üí∞ Creando an√°lisis por rango de presupuesto...")
    
    # Crear categor√≠as de presupuesto
    budget_analysis_df = master_df.withColumn(
        "budget_range",
        when(col("budget") < 1000000, "Bajo: <$1M")
        .when(col("budget") < 10000000, "Medio: $1M-$10M")
        .when(col("budget") < 50000000, "Alto: $10M-$50M")
        .otherwise("Blockbuster: >$50M")
    ).withColumn("is_profitable", when(col("roi") > 0, 1).otherwise(0))
    
    # Agrupar por rango de presupuesto y calcular m√©tricas
    budget_range_analysis = budget_analysis_df.groupBy("budget_range") \
        .agg(
            expr("percentile_approx(roi, 0.5)").alias("roi_mediano"),
            count("id").alias("numero_peliculas"),
            sum("is_profitable").alias("profitable_movies")
        ) \
        .withColumn("success_rate", col("profitable_movies") / col("numero_peliculas")) \
        .withColumn("roi_mediano", round(col("roi_mediano"), 3)) \
        .withColumn("success_rate", round(col("success_rate"), 3)) \
        .orderBy("numero_peliculas")
    
    print(f"üìä Rangos de presupuesto analizados: {budget_range_analysis.count()}")
    
    return budget_range_analysis

def save_curated_products(director_performance_df, genre_performance_df, genre_roi_distribution_df, genre_success_rate_df, budget_range_analysis_df, yearly_trends_df):
    """
    Guarda los productos de datos en la zona CURATED.
    
    Args:
        director_performance_df (DataFrame): KPIs de rendimiento de directores
        genre_performance_df (DataFrame): KPIs de rendimiento de g√©neros
        genre_roi_distribution_df (DataFrame): Distribuci√≥n desagregada de g√©neros y ROI
        genre_success_rate_df (DataFrame): Tasa de √©xito por g√©nero
        budget_range_analysis_df (DataFrame): An√°lisis por rango de presupuesto
        yearly_trends_df (DataFrame): KPIs de tendencias anuales
    """
    print("üíæ Guardando productos de datos en zona CURATED...")
    
    # Guardar rendimiento de directores
    director_output_path = "datalake/curated/director_performance.parquet"
    director_performance_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(director_output_path)
    
    print(f"‚úÖ Rendimiento de directores guardado en: {director_output_path}")
    
    # Guardar rendimiento de g√©neros
    genre_output_path = "datalake/curated/genre_performance.parquet"
    genre_performance_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(genre_output_path)
    
    print(f"‚úÖ Rendimiento de g√©neros guardado en: {genre_output_path}")
    
    # Guardar distribuci√≥n desagregada de g√©neros y ROI
    genre_dist_output_path = "datalake/curated/genre_roi_distribution.parquet"
    genre_roi_distribution_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(genre_dist_output_path)
    
    print(f"‚úÖ Distribuci√≥n de g√©neros y ROI guardada en: {genre_dist_output_path}")
    
    # Guardar tasa de √©xito por g√©nero
    success_rate_output_path = "datalake/curated/genre_success_rate.parquet"
    genre_success_rate_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(success_rate_output_path)
    
    print(f"‚úÖ Tasa de √©xito por g√©nero guardada en: {success_rate_output_path}")
    
    # Guardar an√°lisis por rango de presupuesto
    budget_range_output_path = "datalake/curated/budget_range_analysis.parquet"
    budget_range_analysis_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(budget_range_output_path)
    
    print(f"‚úÖ An√°lisis por rango de presupuesto guardado en: {budget_range_output_path}")
    
    # Guardar tendencias anuales
    yearly_output_path = "datalake/curated/yearly_trends.parquet"
    yearly_trends_df.write \
        .mode("overwrite") \
        .option("compression", "snappy") \
        .parquet(yearly_output_path)
    
    print(f"‚úÖ Tendencias anuales guardadas en: {yearly_output_path}")

def display_business_insights(director_performance_df, genre_performance_df, yearly_trends_df):
    """
    Muestra insights clave del negocio basados en los KPIs generados.
    
    Args:
        director_performance_df (DataFrame): KPIs de rendimiento de directores
        genre_performance_df (DataFrame): KPIs de rendimiento de g√©neros
        yearly_trends_df (DataFrame): KPIs de tendencias anuales
    """
    print("\nüîç INSIGHTS CLAVE DEL NEGOCIO")
    print("=" * 50)
    
    # Top 5 directores por ROI Mediano (m√©tricas m√°s robustas)
    print("\nüèÜ TOP 5 DIRECTORES POR ROI MEDIANO:")
    top_directors = director_performance_df.limit(5).collect()
    if top_directors:
        for i, row in enumerate(top_directors, 1):
            print(f"   {i}. {row['director']} - ROI Mediano: {row['roi_mediano']:.1%} | StdDev: {row['roi_stddev']:.1%} ({row['numero_peliculas']} pel√≠culas)")
    else:
        print("   No hay datos disponibles")
    
    # Top 5 g√©neros por ROI Mediano
    print("\nüé≠ TOP 5 G√âNEROS POR ROI MEDIANO:")
    top_genres = genre_performance_df.limit(5).collect()
    if top_genres:
        for i, row in enumerate(top_genres, 1):
            print(f"   {i}. {row['genre']} - ROI Mediano: {row['roi_mediano']:.1%} | StdDev: {row['roi_stddev']:.1%} ({row['numero_peliculas']} pel√≠culas)")
    else:
        print("   No hay datos disponibles")
    
    # Director m√°s prol√≠fico
    most_prolific = director_performance_df.orderBy(desc("numero_peliculas")).first()
    if most_prolific:
        print(f"\nüìΩÔ∏è  DIRECTOR M√ÅS PROL√çFICO: {most_prolific['director']} ({most_prolific['numero_peliculas']} pel√≠culas)")
    else:
        print(f"\nüìΩÔ∏è  DIRECTOR M√ÅS PROL√çFICO: No disponible")
    
    # Director con mayor ganancia total
    highest_profit = director_performance_df.orderBy(desc("ganancia_total")).first()
    if highest_profit:
        print(f"üí∞ DIRECTOR CON MAYOR GANANCIA TOTAL: {highest_profit['director']} (${highest_profit['ganancia_total']:,.0f})")
    else:
        print(f"üí∞ DIRECTOR CON MAYOR GANANCIA TOTAL: No disponible")
    
    # A√±o m√°s rentable por ROI Mediano
    best_year = yearly_trends_df.orderBy(desc("roi_mediano_anual")).first()
    if best_year:
        print(f"\nüìÖ A√ëO M√ÅS RENTABLE: {best_year['release_year']} (ROI Mediano: {best_year['roi_mediano_anual']:.1%})")
    else:
        print(f"\nüìÖ A√ëO M√ÅS RENTABLE: No disponible")
    
    # A√±o con mayor recaudaci√≥n
    highest_revenue_year = yearly_trends_df.orderBy(desc("recaudacion_total")).first()
    if highest_revenue_year:
        print(f"üéØ A√ëO CON MAYOR RECAUDACI√ìN: {highest_revenue_year['release_year']} (${highest_revenue_year['recaudacion_total']:,.0f})")
    else:
        print(f"üéØ A√ëO CON MAYOR RECAUDACI√ìN: No disponible")

def main():
    """
    Funci√≥n principal que ejecuta el pipeline de agregaci√≥n REFINED -> CURATED.
    """
    print("üöÄ Iniciando Pipeline 3: Refined ‚Üí Curated")
    print("=" * 50)
    
    # Crear sesi√≥n de Spark
    spark = create_spark_session()
    
    try:
        # Crear directorios de salida si no existen
        os.makedirs("datalake/curated", exist_ok=True)
        
        # Paso 1: Cargar dataset maestro
        master_df = load_master_data(spark)
        
        # Paso 2: Crear KPIs de rendimiento de directores
        director_performance_df = create_director_performance_kpis(master_df)
        
        # Paso 3: Crear KPIs de rendimiento de g√©neros
        genre_performance_df = create_genre_performance_kpis(master_df)
        
        # Paso 4: Crear distribuci√≥n desagregada de g√©neros y ROI
        genre_roi_distribution_df = create_genre_roi_distribution(master_df)
        
        # Paso 5: Crear tasa de √©xito por g√©nero
        genre_success_rate_df = create_genre_success_rate(master_df)
        
        # Paso 6: Crear an√°lisis por rango de presupuesto
        budget_range_analysis_df = create_budget_range_analysis(master_df)
        
        # Paso 7: Crear KPIs de tendencias anuales
        yearly_trends_df = create_yearly_trends_kpis(master_df)
        
        # Paso 8: Guardar productos de datos
        save_curated_products(director_performance_df, genre_performance_df, genre_roi_distribution_df, genre_success_rate_df, budget_range_analysis_df, yearly_trends_df)
        
        # Paso 9: Mostrar insights del negocio
        display_business_insights(director_performance_df, genre_performance_df, yearly_trends_df)
        
        print("\nüéâ Pipeline completado exitosamente!")
        print("üìä Productos de datos creados en zona CURATED:")
        print("   ‚Ä¢ director_performance.parquet (KPIs de directores con ROI mediano)")
        print("   ‚Ä¢ genre_performance.parquet (KPIs de g√©neros con ROI mediano)")
        print("   ‚Ä¢ genre_roi_distribution.parquet (Datos desagregados para Box Plot)")
        print("   ‚Ä¢ genre_success_rate.parquet (Tasa de √©xito por g√©nero)")
        print("   ‚Ä¢ budget_range_analysis.parquet (An√°lisis por rango de presupuesto)")
        print("   ‚Ä¢ yearly_trends.parquet (Tendencias anuales con ROI mediano)")
        print("üéØ KPIs listos para dashboards y reportes")
        print("üíº Insights accionables para la toma de decisiones")
        print("üîö Pipeline ETL completo finalizado")
        
    except Exception as e:
        print(f"‚ùå Error durante la agregaci√≥n: {str(e)}")
        raise
    
    finally:
        # Cerrar sesi√≥n de Spark
        spark.stop()

if __name__ == "__main__":
    main() 